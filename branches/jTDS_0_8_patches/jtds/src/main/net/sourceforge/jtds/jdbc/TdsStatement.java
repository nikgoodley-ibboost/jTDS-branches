//
// Copyright 1998 CDS Networks, Inc., Medford Oregon
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//      This product includes software developed by CDS Networks, Inc.
// 4. The name of CDS Networks, Inc.  may not be used to endorse or promote
//    products derived from this software without specific prior
//    written permission.
//
// THIS SOFTWARE IS PROVIDED BY CDS NETWORKS, INC. ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL CDS NETWORKS, INC. BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//



/**
 * A Statement object is used for executing a static SQL statement and
 * obtaining the results produced by it.
 *
 * <p>Only one ResultSet per Statement can be open at any point in time.
 * Therefore, if the reading of one ResultSet is interleaved with the
 * reading of another, each must have been generated by different
 * Statements.  All statement execute methods implicitly close a
 * statement's current ResultSet if an open one exists.
 *
 * @see java.sql.Statement
 * @see ResultSet
 * @version $Id: TdsStatement.java,v 1.33 2004-05-02 22:45:21 bheineman Exp $
 */
package net.sourceforge.jtds.jdbc;

import java.sql.*;
import java.util.ArrayList;
import java.util.Vector;

public class TdsStatement implements java.sql.Statement
{
    /**
     * NOTE: These values are carried over from the new Statement constants
     * introduced in 1.4 in order for the driver to compile with 1.3.
     */
    public static final int RETURN_GENERATED_KEYS = 1;
    public static final int NO_GENERATED_KEYS = 2;
    public static final int SUCCESS_NO_INFO = -2;
    public static final int EXECUTE_FAILED = -3;
    public static final int CLOSE_CURRENT_RESULT = 1;
    public static final int KEEP_CURRENT_RESULT = 2;
    public static final int CLOSE_ALL_RESULTS = 3;

    public static final String cvsVersion = "$Id: TdsStatement.java,v 1.33 2004-05-02 22:45:21 bheineman Exp $";

    protected TdsConnection connection; // The connection that created us

    SQLWarningChain warningChain = new SQLWarningChain(); // The warning chain
    TdsResultSet results = null;
    // @todo Should be removed now as it can cause memory leaks (and there's no need for it)
    protected Vector cursorResults = new Vector();

    private Tds actTds = null;
    private boolean escapeProcessing = true;

    private int updateCount  = -1;
    private int maxFieldSize = (1 << 31) - 1;
    private int maxRows      = 0;
    private int timeout      = 0; // The timeout for a query
    private int fetchSize    = AbstractResultSet.DEFAULT_FETCH_SIZE;
    private int fetchDir     = ResultSet.FETCH_FORWARD;

    private int type = ResultSet.TYPE_FORWARD_ONLY;
    private int concurrency = ResultSet.CONCUR_READ_ONLY;

    private boolean isClosed = false;

    /**
     * Indicates that user wants generated keys.
     */
    private boolean returnKeys = false;

    /**
     * Indicates that the statement returns generated keys (i.e a <code>SELECT
     * SCOPE_IDENTITY()</code> is included in the
     * <code>PreparedStatement</code>).
     * <p>
     * Only applies to <code>PreparedStatement</code>. This is separate from
     * {@link #returnKeys} because <code>returnKeys</code> is modified by the
     * <code>Statement.execute</code> methods.
     */
    private boolean statementReturnsKeys = false;

    /**
     * Custom result set to store generated key values.
     */
    private GenKeyResultSet lastGeneratedKey = null;

    public OutputParamHandler outParamHandler;

    protected ArrayList batchValues = null;

    public TdsStatement(TdsConnection con, int type, int concurrency)
        throws SQLException {
        this.connection = con;
        this.type = type;
        this.concurrency = concurrency;
    }

    /**
     * Constructor for a Statement.  It simply sets the connection
     * that created us.
     *
     * @param  con  the Connection instance that creates us
     */
    public TdsStatement(TdsConnection con) throws SQLException {
        this(con, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    }

    /**
     * Set the "<code>PreparedStatement</code> returns generated keys" flag.
     * This means that a <code>SELECT SCOPE_IDENTITY()</code> was appended to
     * the prepared SQL query.
     *
     * @param value <code>true</code if generated keys are returned;
     *              <code>false</code> otherwise.
     */
    public void statementReturnsKeys(boolean  value) {
        this.statementReturnsKeys = value;
    }

    /**
     * Releases <code>actTds</code> IF there are no outstanding results.
     */
    protected synchronized void releaseTds() throws SQLException {
        // MJH remove test of autoCommit
        if (actTds == null) {
            return;
        }

        // Don't free the Tds if there are any results left.
        /** @todo Check if this is correct in case an IOException occurs */
        if (actTds.moreResults()) {
            return;
        }

        try {
            connection.freeTds(actTds);
            actTds = null;
        } catch (TdsException e) {
            throw new SQLException("Confusion in freeing Tds: " + e);
        }
    }

    protected void NotImplemented() throws java.sql.SQLException {
        throw new SQLException("Not Implemented");
    }

    /**
     * Execute an SQL statement that returns a single <code>ResultSet</code>.
     *
     * @param sql typically a static SQL SELECT statement
     * @return    a <code>ResultSet</code> that contains the data produced by
     *            the query; never <code>null</code>
     * @exception SQLException if a database access error occurs
     */
    public ResultSet executeQuery(String sql) throws SQLException {
        checkClosed();
        SQLWarning warn = null;

        // MJH - Return keys never valid for this type of call
        this.returnKeys = false;

        if (type != ResultSet.TYPE_FORWARD_ONLY
                || concurrency != ResultSet.CONCUR_READ_ONLY) {
            // Try to create a cursor
            try {
                ResultSet rs = new CursorResultSet(this, sql, fetchDir, null);
                cursorResults.add(rs);
                return rs;
            } catch (SQLException e) {
                // @todo Should check the error code, to make sure it was not
                //       caused by something else
                // Cursor creation failed, add a warning
                warn = new SQLWarning(
                        e.getMessage(), e.getSQLState(), e.getErrorCode());
            }
        }

        boolean res = internalExecute(sql);
        // If we had a warning we have to put it in the warning chain here,
        // because internalExecute clears the warning chain
        if (warn != null) {
            warningChain.addWarning(warn);
        }

        if (res) {
            return results;
        } else {
            throw new SQLException("No ResultSet was produced.");
        }
    }

    /**
     * This is the internal function that all subclasses should call.
     * It is not executeQuery() to allow subclasses (in particular
     * CursorResultSet) to override that functionality without
     * breaking the internal methods.
     *
     * @param sql any SQL statement
     * @return true if the next result is a ResulSet, false if it is
     *      an update count or there are no more results
     * @exception SQLException if a database access error occurs
     */
    public final synchronized boolean internalExecute(String sql) throws SQLException {
        // checkClosed();
        // MJH - Invoke other method to simplify get gen keys logic
        return internalExecute(sql, getTds(), warningChain);
        // return executeImpl(getTds(), sql, warningChain);
    }

    public final synchronized boolean internalExecute(
            String sql, Tds tds, SQLWarningChain wChain) throws SQLException {
    	// MJH - Changed to get the results without freeing the Tds object so
    	// we can call SELECT @@IDENTITY if requred.
        try {
            checkClosed();

            boolean result = executeImpl(tds, sql, wChain);
            internalGetGeneratedKeys(tds, result, false); // MJH Get the keys if required

            return result;
        } finally {
            releaseTds(); // MJH - OK we can free the Tds now if required.
        }
    }

    private final boolean executeImpl(Tds tds, String sql, SQLWarningChain wChain)
        throws SQLException {
        // Clear warnings, otherwise the last exception will be thrown.
        wChain.clearWarnings();
        updateCount = -1;

        // Consume all outstanding results. Otherwise it will either deadlock,
        // crash or return results from the previous query.
        skipToEnd();

        if (escapeProcessing) {
            sql = EscapeProcessor.nativeSQL(sql);
        }

        tds.executeQuery(sql, this, wChain, timeout);

        // SAfe We must do this to ensure we throw SQLExceptions on timed out
        //      statements
        wChain.checkForExceptions();

        // return getMoreResults(tds, wChain, true);
        // MJH - We do not want to free the Tds in case we
        // need to get the generated keys.
        return getMoreResults(tds, wChain, false);
    }

    public final synchronized boolean internalExecuteCall(String name, ParameterListItem[] formalParameterList,
        ParameterListItem[] actualParameterList, Tds tds, SQLWarningChain wChain) throws SQLException {
        checkClosed();
        return executeCallImpl(tds, name, formalParameterList, actualParameterList, wChain);
    }

    private boolean executeCallImpl(Tds tds, String name, ParameterListItem[] formalParameterList,
        ParameterListItem[] actualParameterList, SQLWarningChain wChain) throws SQLException {
        try {
            wChain.clearWarnings();
            // SAfe This is where all outstanding results must be skipped, to make
            //      sure they don't interfere with the the current ones.
            skipToEnd();

            boolean result;
            this.lastGeneratedKey = null;

            // execute the stored procedure.
            tds.executeProcedure(name, formalParameterList, actualParameterList,
                                 this, wChain, getQueryTimeout(), false);

            // MJH - We do not want to free the Tds before checking to
            // see if we need to get the generated keys.
            result = getMoreResults(tds, warningChain, false);

            internalGetGeneratedKeys(tds, result, true);
//            if (this.statementReturnsKeys && tds.moreResults() && !result) {
//                //
//                // MJH - OK We need to get the @@IDENTITY value
//                //
//                int saveCount = this.updateCount;
//
//                if (getMoreResults(tds, new SQLWarningChain(), false)) {
//                    // Construct special result set
//                    this.lastGeneratedKey = new GenKeyResultSet(this, this.results);
//                    this.results.close();
//                    this.results = null;
//                }
//
//                this.updateCount = saveCount;
//                result = false;
//            }

            return result;
        } finally {
            releaseTds();
        }
    }

    /**
     * Execute a SQL INSERT, UPDATE or DELETE statement.  In addition
     * SQL statements that return nothing such as SQL DDL statements
     * can be executed
     *
     * @param  sql  an SQL statement
     * @return      either a row count, or 0 for SQL commands
     * @exception SQLException if a database access error occurs
     */
    public synchronized int executeUpdate(String sql) throws SQLException {
        try {
            checkClosed();

            // MJH - Block return keys for this type of executeUpdate()
            this.returnKeys = false;

            if (internalExecute(sql)) {
                skipToEnd();
                throw new SQLException("executeUpdate can't return a result set");
            } else {
                int res;

                if (connection.returnLastUpdateCount()) {
                    int lastUpdateCount = 0;

                    while ((res = getUpdateCount()) != -1) {
                        lastUpdateCount = res;

                        // If we found a ResultSet, there's a problem.
                        if (getMoreResults()) {
                            skipToEnd();
                            throw new SQLException(
                                    "executeUpdate can't return a result set");
                        }
                    }

                    return lastUpdateCount;
                } else {
                    res = getUpdateCount();
                    // We should return 0 (at least that's what the javadoc above says)
                    return (res == -1) ? 0 : res;
                }
            }
        } finally {
            releaseTds();
        }
    }

    protected synchronized void closeResults(boolean allowTdsRelease)
        throws SQLException {
        updateCount = -1;

        if (results != null) {
            results.close(allowTdsRelease);
            results = null;
        }
    }

    /**
     * Eats all available input from the server. Not very efficient (since it
     * reads in all data by creating <code>ResultSets</code> and processing
     * them), but at least it works (the old version would crash when reading in
     * a row because it didn't have any information about the row's Context).
     * <p>
     * This could be changed to use the <code>TdsComm</code> to read in all the
     * server response without processing it, but that requires some changes in
     * <code>TdsComm</code>, too.
     */
    protected synchronized void skipToEnd() throws SQLException {
        closeResults(false);

        if (actTds != null) {
            actTds.skipToEnd();
        }
    }

    /**
     * In many cases, it is desirable to immediately release a
     * Statement's database and JDBC resources instead of waiting
     * for this to happen when it is automatically closed.  The
     * close method provides this immediate release.
     *
     * <p><B>Note:</B> A Statement is automatically closed when it is
     * garbage collected.  When a Statement is closed, its current
     * ResultSet, if one exists, is also closed.
     *
     * @exception SQLException if a database access error occurs (why?)
     */
    public synchronized void close() throws SQLException {
        if (isClosed) {
            return;
        }

        if (actTds != null) {
            // Tds not yet released.
            try {
                // SAfe: Must do this to ensure no garbage is left behind
                closeResults(false);

                if (!connection.isClosed()) {
                    actTds.skipToEnd();
                }

                // MJH Do not Rollback any pending transactions!
                connection.freeTds(actTds);
                actTds = null;
            } catch (net.sourceforge.jtds.jdbc.TdsException e) {
                throw new SQLException(e.toString());
            }
        }

        if (!connection.isClosed()) {
            // Synch on the Vector, to make sure it doesn't get changed
            synchronized (cursorResults) {
                for (int i=cursorResults.size()-1; i>=0; i--) {
                    CursorResultSet rs = (CursorResultSet)cursorResults.get(i);
                    rs.close();
                }
            }
        }

        cursorResults.clear();

        // SAfe Mark Statement as closed internally, too
        isClosed = true;
    }

    /**
     * Make sure we release the <code>Tds</code> when we're no longer in use.
     * This is safe to do even in the case of <code>DatabaseMetaData</code> or
     * other cases where the reference to the <code>Statement</code> is lost
     * and only a reference to a <code>ResultSet</code> is kept, because the
     * <code>TdsResultSet</code> has an internal reference to the
     * <code>Statement</code> so <code>finalize()</code> won't get called yet.
     * @throws SQLException
     */
    public void finalize() throws SQLException {
        close();
    }

    /**
     * The maxFieldSize limit (in bytes) is the maximum amount of
     * data returned for any column value; it only applies to
     * BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR and LONGVARCHAR
     * columns.  If the limit is exceeded, the excess data is silently
     * discarded.
     *
     * @return the current max column size limit; zero means unlimited
     * @exception SQLException if a database access error occurs
     */
    public synchronized int getMaxFieldSize() throws SQLException {
        checkClosed();
        return maxFieldSize;
    }

    /**
     * Sets the maxFieldSize
     *
     * @param max the new max column size limit; zero means unlimited
     * @exception SQLException if size exceeds buffer size
     */
    public synchronized void setMaxFieldSize(int max) throws SQLException {
        checkClosed();
        maxFieldSize = max;
    }

    /**
     * The maxRows limit is set to limit the number of rows that
     * any ResultSet can contain.  If the limit is exceeded, the
     * excess rows are silently dropped.
     *
     * @return the current maximum row limit; zero means unlimited
     * @exception SQLException if a database access error occurs
     */
    public synchronized int getMaxRows() throws SQLException {
        checkClosed();
        return maxRows;
    }

    /**
     * Set the maximum number of rows
     *
     * @param max the new max rows limit; zero means unlimited
     * @exception SQLException if a database access error occurs
     * @see #getMaxRows
     */
    public synchronized void setMaxRows(int max) throws SQLException {
        checkClosed();

        if (maxRows < 0) {
            throw new SQLException("Negative row count");
        }

        maxRows = max;
    }

    /**
     * If escape scanning is on (the default), the driver will do escape
     * substitution before sending the SQL to the database.
     *
     * @param enable true to enable; false to disable
     * @exception SQLException if a database access error occurs
     */
    public synchronized void setEscapeProcessing(boolean enable) throws SQLException {
        checkClosed();
        escapeProcessing = enable;
    }

    /**
     * The queryTimeout limit is the number of seconds the driver
     * will wait for a Statement to execute.  If the limit is
     * exceeded, a SQLException is thrown.
     *
     * @return the current query timeout limit in seconds; 0 = unlimited
     * @exception SQLException if a database access error occurs
     */
    public synchronized int getQueryTimeout() throws SQLException {
        checkClosed();
        return timeout;
    }

    /**
     * Sets the queryTimeout limit
     *
     * @param seconds - the new query timeout limit in seconds
     * @exception SQLException if a database access error occurs
     */
    public synchronized void setQueryTimeout(int seconds) throws SQLException {
        checkClosed();
        timeout = seconds;
    }

   /**
    *
    * @exception SQLException
    */
    public void cancel() throws SQLException {
        checkClosed();

        try {
            if (actTds != null) {
                actTds.cancel();
            }
        } catch (net.sourceforge.jtds.jdbc.TdsException e) {
            throw TdsUtil.getSQLException(null, null, e);
        } catch (java.io.IOException e) {
            throw TdsUtil.getSQLException(null, null, e);
        }
    }

    /**
     * The first warning reported by calls on this Statement is
     * returned.  A Statement's execute methods clear its SQLWarning
     * chain.  Subsequent Statement warnings will be chained to this
     * SQLWarning.
     *
     * <p>The Warning chain is automatically cleared each time a statement
     * is (re)executed.
     *
     * <p><B>Note:</B>  If you are processing a ResultSet then any warnings
     * associated with ResultSet reads will be chained on the ResultSet
     * object.
     *
     * @return the first SQLWarning on null
     * @exception SQLException if a database access error occurs
     */
    public synchronized SQLWarning getWarnings() throws SQLException {
        checkClosed();
        return warningChain.getWarnings();
    }


   /**
    * After this call, getWarnings returns null until a new warning
    * is reported for this Statement.
    *
    * @exception SQLException if a database access error occurs (why?)
    */
    public synchronized void clearWarnings() throws SQLException {
        checkClosed();
        warningChain.clearWarnings();
    }

    /**
     * setCursorName defines the SQL cursor name that will be used by
     * subsequent execute methods.  This name can then be used in SQL
     * positioned update/delete statements to identify the current row
     * in the ResultSet generated by this statement.  If a database
     * doesn't support positioned update/delete, this method is a
     * no-op.
     *
     * @param name the new cursor name
     * @exception SQLException if a database access error occurs
     */
    public void setCursorName(String name) throws SQLException {
        // SAfe As the javadoc above says, this should be a no-op.
    }

    public synchronized boolean execute(String sql) throws SQLException {
        checkClosed();

        // MJH - Block return keys action for this type of execute
        this.returnKeys = false;

        return internalExecute(sql);
    }

    synchronized Tds getTds() throws SQLException {
        if (actTds == null) {
            actTds = connection.allocateTds(false);
        }

        return actTds;
    }

    /**
     * getResultSet returns the current result as a ResultSet.  It
     * should only be called once per result.
     *
     * @return the current result set; null if there are no more
     * @exception SQLException if a database access error occurs
     */
    public synchronized java.sql.ResultSet getResultSet() throws SQLException {
        checkClosed();
        return results;
    }

    /**
     * getUpdateCount returns the current result as an update count,
     * if the result is a ResultSet or there are no more results, -1
     * is returned.  It should only be called once per result.
     *
     * @return the current result as an update count.
     * @exception SQLException if a database access error occurs
     */
    public synchronized int getUpdateCount() throws SQLException {
        checkClosed();
        return updateCount;
    }

    /**
     * getMoreResults moves to a Statement's next result.  If it returns
     * true, this result is a ResulSet.
     *
     * @return true if the next ResultSet is valid
     * @exception SQLException if a database access error occurs
     */
    public synchronized boolean getMoreResults() throws SQLException {
        checkClosed();
        return getMoreResults(actTds, warningChain, true);
    }

    public boolean getMoreResults(int current) throws SQLException {
        NotImplemented();
        return false;
    }

    boolean handleRetStat(PacketRetStatResult packet) {
        return outParamHandler!=null && outParamHandler.handleRetStat(packet);
    }

    boolean handleParamResult(PacketOutputParamResult packet)
        throws SQLException {
        return outParamHandler != null && outParamHandler.handleParamResult(packet);
    }

    synchronized boolean getMoreResults(Tds tds, SQLWarningChain wChain, boolean allowTdsRelease)
        throws SQLException {
        updateCount = -1;

        if (tds == null) {
            return false;
        }

        // Reset all internal variables (do it before checking for more results)
        closeResults(false);

        // SAfe Synchronize on the Tds to make sure noone else can call
        //      Tds.skipToEnd while we're processing the results
        synchronized (tds) {
            try {
                do {
                    tds.goToNextResult(wChain, this);

                    if (!tds.moreResults()) {
                        if (allowTdsRelease) {
                            releaseTds();
                        }

                        wChain.checkForExceptions();
                        return false;
                    }

                    // SAfe We found a ResultSet
                    if (tds.isResultSet()) {
                        results = new TdsResultSet(tds, this, wChain, fetchSize);
                        wChain.checkForExceptions();
                        return true;
                    }

                    // SAfe It's an end token.
                    PacketEndTokenResult end =
                        (PacketEndTokenResult) tds.processSubPacket();
                    updateCount = end.getRowCount();
                    if (Tds.handleEndToken(end, wChain)) {
                        wChain.checkForExceptions();
                    }

                    // SAfe Eat up all packets until the next result or the end
                    tds.goToNextResult(wChain, this);
                } while (updateCount == -1 && tds.moreResults());

                if (allowTdsRelease) {
                    releaseTds();
                }

                wChain.checkForExceptions();
                return false;
            } catch (Exception e) {
                releaseTds();

                if (e instanceof SQLException) {
                    throw (SQLException) e;
                } else {
                    throw TdsUtil.getSQLException("Network error", null, e);
                }
            }
        }
    }

    //--------------------------JDBC 2.0-----------------------------

    /**
     * JDBC 2.0
     *
     * Gives the driver a hint as to the direction in which
     * the rows in a result set
     * will be processed. The hint applies only to result sets created
     * using this Statement object.  The default value is
     * ResultSet.FETCH_FORWARD.
     * <p>Note that this method sets the default fetch direction for
     * result sets generated by this <code>Statement</code> object.
     * Each result set has its own methods for getting and setting
     * its own fetch direction.
     * @param direction the initial direction for processing rows
     * @exception SQLException if a database access error occurs
     * or the given direction
     * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
     * ResultSet.FETCH_UNKNOWN
     */
    public void setFetchDirection(int direction) throws SQLException {
        if (direction != ResultSet.FETCH_FORWARD
            && direction != ResultSet.FETCH_REVERSE
            && direction != ResultSet.FETCH_UNKNOWN) {
            throw new SQLException("Invalid fetch direction.");
        }

        fetchDir = direction;
    }

    /**
     * JDBC 2.0
     *
     * Retrieves the direction for fetching rows from
     * database tables that is the default for result sets
     * generated from this <code>Statement</code> object.
     * If this <code>Statement</code> object has not set
     * a fetch direction by calling the method <code>setFetchDirection</code>,
     * the return value is implementation-specific.
     *
     * @return the default fetch direction for result sets generated
     *          from this <code>Statement</code> object
     * @exception SQLException if a database access error occurs
     */
    public int getFetchDirection() throws SQLException {
        return fetchDir;
    }

    /**
     * JDBC 2.0
     *
     * Gives the JDBC driver a hint as to the number of rows that should
     * be fetched from the database when more rows are needed.  The number
     * of rows specified affects only result sets created using this
     * statement. If the value specified is zero, then the hint is ignored.
     * The default value is zero.
     *
     * @param rows the number of rows to fetch
     * @exception SQLException if a database access error occurs, or the
     * condition 0 <= rows <= this.getMaxRows() is not satisfied.
     */
    public void setFetchSize(int rows) throws SQLException {
        if (rows < 0) {
            throw new SQLException("Invalid fetch size.");
        }

        fetchSize = rows;
    }

    /**
     * JDBC 2.0
     *
     * Retrieves the number of result set rows that is the default
     * fetch size for result sets
     * generated from this <code>Statement</code> object.
     * If this <code>Statement</code> object has not set
     * a fetch size by calling the method <code>setFetchSize</code>,
     * the return value is implementation-specific.
     * @return the default fetch size for result sets generated
     *          from this <code>Statement</code> object
     * @exception SQLException if a database access error occurs
     */
    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    /**
     * JDBC 2.0
     *
     * Retrieves the result set concurrency.
     * <p>
     * <b>Note:</b> No need for synchronization. Value never changes.
     */
    public int getResultSetConcurrency() throws SQLException {
        checkClosed();
        return concurrency;
    }

    /**
     * JDBC 2.0
     *
     * Determine the result set type.
     * <p>
     * <b>Note:</b> No need for synchronization. Value never changes.
     */
    public int getResultSetType()  throws SQLException {
        checkClosed();
        return type;
    }

    /**
     * JDBC 2.0
     *
     * Adds a SQL command to the current batch of commmands for the statement.
     * This method is optional.
     *
     * @param sql typically this is a static SQL INSERT or UPDATE statement
     * @exception SQLException if a database access error occurs, or the
     * driver does not support batch statements
     */
    public synchronized void addBatch(String sql) throws SQLException {
        if (batchValues == null) {
            batchValues = new ArrayList();
        }

        batchValues.add(sql);
    }

    /**
     * JDBC 2.0
     *
     * Makes the set of commands in the current batch empty.
     * This method is optional.
     *
     * @exception SQLException if a database access error occurs or the
     * driver does not support batch statements
     */
    public synchronized void clearBatch() throws SQLException {
        if (batchValues != null)
            batchValues.clear();
    }

    /**
     * JDBC 2.0
     *
     * Submits a batch of commands to the database for execution.
     * This method is optional.
     *
     * @return an array of update counts containing one element for each
     * command in the batch.  The array is ordered according
     * to the order in which commands were inserted into the batch.
     * @exception SQLException if a database access error occurs or the
     * driver does not support batch statements
     */
    public synchronized int[] executeBatch() throws SQLException {
        int size = (batchValues == null) ? 0 : batchValues.size();
        int[] updateCounts = new int[size];
        int i = 0;

        try {
            for (; i < size; i++) {
                Object value = batchValues.get(i);

                if (value instanceof String) {
                    updateCounts[i] = executeUpdate((String) value);
                } else {
                    updateCounts[i] = executeBatchOther(value);
                }
            }
        } catch (SQLException e) {
            int[] tmpUpdateCounts = new int[i + 1];

            System.arraycopy(updateCounts, 0, tmpUpdateCounts, 0, i + 1);

            tmpUpdateCounts[i] = EXECUTE_FAILED;
            throw new BatchUpdateException(e.getMessage(), tmpUpdateCounts);
        } finally {
            clearBatch();
        }

        return updateCounts;
    }

    /**
     * This method should be over-ridden by any sub-classes that place values other than
     * Strings into the batchValues list to handle execution properly.
     */
    protected int executeBatchOther(Object value) throws SQLException {
        throw new SQLException("Unable to execute batch value: " + value);
    }

    /**
     * JDBC 2.0
     *
     * Returns the <code>Connection</code> object
     * that produced this <code>Statement</code> object.
     * <p>
     * <b>Note:</b> No need for synchromization here. <code>connection</code>
     * doesn't change during execution (not even after <code>close()</code>.
     *
     * @return the connection that produced this statement
     * @exception SQLException if a database access error occurs
     */
    public java.sql.Connection getConnection() throws SQLException {
        checkClosed();
        return connection;
    }

    void checkClosed() throws SQLException {
        if (isClosed) {
            throw new SQLException("Statement already closed.");
        }

        connection.checkClosed();
    }

    //
    // MJH - Add option to request return of generated keys.
    //
    public boolean execute(String str, int param) throws SQLException {
        checkClosed();

        if (param == RETURN_GENERATED_KEYS
            && str.trim().substring(0, 6).equalsIgnoreCase("INSERT")) {
            this.returnKeys = true;
        } else {
            this.returnKeys = false;
        }

        return internalExecute(str);
    }

    //
    // MJH - Add option to request return of generated keys.
    // NB. SQL Server only allows one IDENTITY column per table so
    // cheat here and don't process the column parameter in detail.
    //
    public boolean execute(String str, String[] str1) throws SQLException {
        if (str1 == null) {
            throw new SQLException("str1 cannot be null.");
        } else if (str1.length != 1) {
            throw new SQLException("One valid column name must be supplied");
        }

        return execute(str, RETURN_GENERATED_KEYS);
    }

    //
    // MJH - Add option to request return of generated keys.
    // NB. SQL Server only allows one IDENTITY column per table so
    // cheat here and don't process the column parameter in detail.
    //
    public boolean execute(String str, int[] values) throws SQLException {
        if (values == null) {
            throw new SQLException("values cannot be null.");
        } else if (values.length != 1) {
            throw new SQLException("One valid column index must be supplied.");
        }

        return execute(str, RETURN_GENERATED_KEYS);
    }

    //
    // MJH - Add option to request return of generated keys.
    // NB. SQL Server only allows one IDENTITY column per table so
    // cheat here and don't process the column parameter in detail.
    //
    public int executeUpdate(String str, String[] str1) throws SQLException {
        if (str1 == null) {
            throw new SQLException("str1 cannot be null.");
        } else if (str1.length != 1) {
            throw new SQLException("One valid column name must be supplied.");
        }

        return executeUpdate(str, RETURN_GENERATED_KEYS);
    }

    //
    // MJH - Add option to request return of generated keys.
    // NB. SQL Server only allows one IDENTITY column per table so
    // cheat here and don't process the column parameter in detail.
    //
    public int executeUpdate(String str, int[] values) throws SQLException {
        if (values == null) {
            throw new SQLException("values cannot be null.");
        } else if (values.length != 1) {
            throw new SQLException("One valid column index must be supplied.");
        }

        return executeUpdate(str, RETURN_GENERATED_KEYS);
    }

    //
    // MJH - Add option to request return of generated keys.
    //
    public int executeUpdate(String str, int param) throws SQLException {
        checkClosed();

        if (param == RETURN_GENERATED_KEYS
            && str.trim().substring(0, 6).equalsIgnoreCase("INSERT")) {
            this.returnKeys = true;
        } else {
            this.returnKeys = false;
        }

        if (internalExecute(str)) {
            skipToEnd();
            throw new SQLException("executeUpdate can't return a result set.");
        } else {
            int res = getUpdateCount();
            // We should return 0 (at least that's what the javadoc above says)
            return (res == -1) ? 0 : res;
        }
    }

    //
    // MJH - At last! Return the special result set containing the
    // key generated by the last insert statement.
    //
    public ResultSet getGeneratedKeys() throws SQLException {
        checkClosed();
        return(this.lastGeneratedKey != null) ? this.lastGeneratedKey : new GenKeyResultSet(this);
    }

    public int getResultSetHoldability() throws java.sql.SQLException {
        NotImplemented();
        return Integer.MIN_VALUE;
    }

    //
    // MJH - This method calls SELECT @@IDENTIY to obtain the value of the
    // last generated IDENTIY column. The value is stored in special resultSet
    // for late use in the getGeneratedKeys() method.
    //
    private void internalGetGeneratedKeys(Tds tds,
                                          boolean result,
                                          boolean alreadySubmitted)
            throws SQLException {
        this.lastGeneratedKey = null;

        if ((this.returnKeys || this.statementReturnsKeys)
            && !result
            && (tds.moreResults() == alreadySubmitted)) {

            //
            // Routine only used by Statement
            //
            int saveCount = this.updateCount; // Original value will be reset to -1 by getMoreResults()

            try {
                SQLWarningChain tmpWarnings = new SQLWarningChain();

                if (!alreadySubmitted) {
                    // SCOPE_IDENTITY() is prefered as it avoids problems with
                    // counts returned from triggers.
                    // @@IDENTITY is required for SQL 6.5/Sybase in all cases.
                    //
                    String sql;

                    if (tds.getServerType() == Tds.SQLSERVER
                            && connection.getDatabaseMajorVersion() >= 8) {
                        sql = "SELECT SCOPE_IDENTITY() AS ID";
                    } else {
                        sql = "SELECT @@IDENTITY AS ID";
                    }
                    tds.executeQuery(sql, this, tmpWarnings, timeout);
                }

                if (getMoreResults(tds, tmpWarnings, false)) {
                    // Construct a special result set.
                    this.lastGeneratedKey = new GenKeyResultSet(this, this.results);
                    this.results.close();
                    this.results = null;
                } else {
                    throw new SQLException("Expected generated keys ResultSet.");
                }
            } catch (SQLException e) {
                throw e;
            } catch (Exception e) {
                throw TdsUtil.getSQLException(null, null, e);
            } finally {
                this.results = null; // Tidy up.
                this.updateCount = saveCount; // Restore original count.
            }
        }
    }
}
